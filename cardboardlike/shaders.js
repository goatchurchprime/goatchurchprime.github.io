shaders = { "X":"",
	"fragment_shader_centreline":"	uniform vec4 closecolour; 	uniform float closedist; 	uniform float selectedvsvxcaveindex; 	uniform float redalt; 	uniform float vfac; 	varying float altitude; 	varying float vcosslope; 	varying float vsvxcaveindex; 	float midlump(float v, float offset) 	{	    float lv = (mod(v*vfac + offset, 1.0) - 0.5)/0.5; 	    return clamp(1.0 - lv*lv, 0.0, 1.0); 	}	void main(void) 	{	    float redalt = 0.1; 	    vec4 ptcolour = vec4(midlump(altitude, redalt), midlump(altitude, redalt-0.667)*0.98, midlump(altitude, redalt-0.333), 1.0); 	    vec4 sptcolour = mix(ptcolour, vec4(0.0, 0.0, 0.0, 1.0), 0.6*(1.0-vcosslope)); 	    float fdepth = gl_FragCoord.z / gl_FragCoord.w; 	    float cfac = clamp((closedist - fdepth)*0.1, 0.0, 0.81); 	    if (vsvxcaveindex == selectedvsvxcaveindex)	        gl_FragColor = mix(sptcolour, vec4(0.0, 1.0, 1.0, 1.0), 0.8); 	    else	        gl_FragColor = mix(sptcolour, closecolour, cfac); 	}	  ",
	"vertexShader_centreline":"	attribute float cosslope; 	attribute float svxcaveindex; 	varying float altitude; 	varying float vcosslope; 	varying float vsvxcaveindex; 	void main()	{	    altitude = position.y; 	    vcosslope = cosslope; 	    vsvxcaveindex = svxcaveindex;  	    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );	    gl_Position = projectionMatrix * mvPosition; 	}	  ",
	"fragment_shader_textlabel":"	uniform vec4 closecolour; 	uniform float closedist; 	uniform sampler2D texture;	varying vec2 vUv;	void main() 	{	    vec2 uv = vec2(vUv.x, vUv.y);	    vec3 color = texture2D(texture, uv).rgb;	    if (color.y == 0.0)	        discard; 	    vec4 sptcolour = vec4(color, 1.0);		    	    float fdepth = gl_FragCoord.z / gl_FragCoord.w; 	    float cfac = clamp((closedist - fdepth)*0.1, 0.0, 0.81); 	    gl_FragColor = mix(sptcolour, closecolour, (color.y >= 0.5 ? cfac : 0.0)); 	}	  ",
	"vertex_shader_textlabel":"	uniform float aspect; 	uniform float pixelsize; 	uniform float textureaspect; 	varying vec2 vUv;	void main()	{	    vUv = uv;	    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);	    gl_Position = projectionMatrix * mvPosition; 	    float spixelsize = pixelsize*gl_Position.z; 	    gl_Position.x += uv.x*spixelsize*textureaspect; 	    gl_Position.y += uv.y*spixelsize*aspect; 	}	  ",
	"vertexShader_peaktriangle":"	uniform float trianglesize; 	uniform float aspect; 	attribute float pcorner; 	void main()	{	    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);	    gl_Position = projectionMatrix * mvPosition; 	    float strianglesize = trianglesize*gl_Position.z; 	    if (pcorner != 0.0) {	        	        gl_Position += projectionMatrix*viewMatrix[1]*(-strianglesize) + projectionMatrix*viewMatrix[0]*((pcorner == 1.0 ? 1.0 : -1.0) * 0.57735*strianglesize); 	        	        	    }	}	  ",
	"vertex_shader_enttriangle":"	uniform float trianglesize; 	uniform float aspect; 	attribute float pcorner; 	attribute float svxcaveindex; 	varying float altitude; 	varying float vcosslope; 	varying float vsvxcaveindex; 	void main()	{	    altitude = position.y; 	    vcosslope = 1.0; 	    vsvxcaveindex = svxcaveindex; 	    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);	    gl_Position = projectionMatrix * mvPosition; 	    float strianglesize = trianglesize*gl_Position.z*10.0; 	    if (pcorner != 0.0) {	        gl_Position.y += strianglesize*aspect; 	        gl_Position.x += (pcorner == 1.0 ? 1.0 : -1.0) * 0.57735*strianglesize*0.5; 	    }	}	  "
}
