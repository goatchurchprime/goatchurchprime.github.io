<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ding</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body { margin: 0px; overflow: hidden; }
      #viz { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
      #quantbutton { position: absolute; right:0; top: 0; border: thin red solid; background:#ddf; display: block }
      #quantshow { position: absolute; right:0; top: 0; width: 75%; border: thin red solid; background:#ddf; display: block }
      #quantshowtext { font-size: 200%; position: relative; left: 0; top: 0; display: none }
      #postext { position: relative; left: 0; top: 0; display: block }
      #postext input, #quantbutton input { font-size: 150%}
    </style>
    <link rel="manifest" href="manifest.json">
    <script src="three.min.js"></script>
    <script src="DeviceOrientationControls.js?2"></script>
    <script src="all3d.js"></script>
    <script src="positionfuncs.js"></script>
  </head>
  <body>
    <div id="main">
      <div id="viz"></div>
      <div id="quantbutton">
        <input type="button" value="Q" id="qshow"/>
      </div>
      <div id="quantshow">
        <div id="quantshowtext">TEE</div>
        <div id="postext">
          <div id="numpanel">
              <span id="gpsrec">Dgps</span>
              <span id="testout">:</span>
          </div>
          <div>
              <input type="button" value="Hop" id="camerahop"/>
              <input type="button" value="Cen" id="reset31"/>
              <input type="button" value="Mag" id="magorientset"/>
              <input type="button" value="T1" id="test1"/>
          </div>
        </div>
      </div>
    </div>

  <script id="fragment_shader_centreline" type="x-shader/x-fragment">
uniform vec4 closecolour; 
uniform float closedist; 
uniform float selectedvsvxcaveindex; 
varying float altitude; 
varying float vcosslope; 
varying float vsvxcaveindex; 
float midlump(float v, float offset) 
{
    float lv = (mod(v*0.1 + offset, 100.0) - 50.0)/50.0; 
    return clamp(1.0 - lv*lv*1.0, 0.0, 1.0); 
}
void main(void) 
{
    float redalt = 70.0; 
    vec4 ptcolour = vec4(midlump(altitude, redalt), midlump(altitude, redalt-67.0)*0.98, midlump(altitude, redalt-33.0), 1.0); 
    vec4 sptcolour = mix(ptcolour, vec4(0.0, 0.0, 0.0, 1.0), 0.6*(1.0-vcosslope)); 
    float fdepth = gl_FragCoord.z / gl_FragCoord.w; 
    float cfac = clamp((closedist - fdepth)*0.1, 0.0, 0.81); 
    if (vsvxcaveindex == selectedvsvxcaveindex)
        gl_FragColor = mix(sptcolour, vec4(0.0, 1.0, 1.0, 1.0), 0.8); 
    else
        gl_FragColor = mix(sptcolour, closecolour, cfac); 
}
  </script>
  <script id="vertexShader_centreline" type="x-shader/x-vertex">
attribute float cosslope; 
attribute float svxcaveindex; 
varying float altitude; 
varying float vcosslope; 
varying float vsvxcaveindex; 
void main()
{
    altitude = position.y; 
    vcosslope = cosslope; 
    vsvxcaveindex = svxcaveindex;  
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix * mvPosition; 
}
  </script>



  <script id="fragment_shader_textlabel" type="x-shader/x-fragment">
uniform vec4 closecolour; 
uniform float closedist; 
uniform sampler2D texture;
varying vec2 vUv;
void main() 
{
    vec2 uv = vec2(vUv.x, vUv.y);
    vec3 color = texture2D(texture, uv).rgb;
    if (color.y == 0.0)
        discard; 
    vec4 sptcolour = vec4(color, 1.0);

    // color.y >= 0.5 separates out the aliased dark part of the text texture from the internal pixels of the letters
    float fdepth = gl_FragCoord.z / gl_FragCoord.w; 
    float cfac = clamp((closedist - fdepth)*0.1, 0.0, 0.81); 
    gl_FragColor = mix(sptcolour, closecolour, (color.y >= 0.5 ? cfac : 0.0)); 
}
  </script>
  
  
  <script id="vertex_shader_textlabel" type="x-shader/x-fragment">
uniform float aspect; 
uniform float pixelsize; 
uniform float textureaspect; 
varying vec2 vUv;
void main()
{
    vUv = uv;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition; 
    float spixelsize = pixelsize*gl_Position.z; 
    gl_Position.x += uv.x*spixelsize*textureaspect; 
    gl_Position.y += uv.y*spixelsize*aspect; 
}
  </script>


  <script id="vertexShader_peaktriangle" type="x-shader/x-vertex">
uniform float trianglesize; 
uniform float aspect; 
attribute float pcorner; 
void main()
{
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition; 
    float strianglesize = trianglesize*gl_Position.z; 
    if (pcorner != 0.0) {
        // this is now attempting to draw the triangle fixed even with spin rotation of the screen
        gl_Position += projectionMatrix*viewMatrix[1]*(-strianglesize) + projectionMatrix*viewMatrix[0]*((pcorner == 1.0 ? 1.0 : -1.0) * 0.57735*strianglesize); 
        //gl_Position.y += strianglesize*aspect; 
        //gl_Position.x += (pcorner == 1.0 ? 1.0 : -1.0) * 0.57735*strianglesize; 
    }
}
  </script>
  

  <script id="vertex_shader_enttriangle" type="x-shader/x-vertex">
uniform float trianglesize; 
uniform float aspect; 
attribute float pcorner; 
attribute float svxcaveindex; 
varying float altitude; 
varying float vcosslope; 
varying float vsvxcaveindex; 
void main()
{
    altitude = position.y; 
    vcosslope = 1.0; 
    vsvxcaveindex = svxcaveindex; 
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition; 
    float strianglesize = trianglesize*gl_Position.z*10.0; 
    if (pcorner != 0.0) {
        gl_Position.y += strianglesize*aspect; 
        gl_Position.x += (pcorner == 1.0 ? 1.0 : -1.0) * 0.57735*strianglesize*0.5; 
    }
}
  </script>
  
  <script>
var basepositionOrigin, latR, lngR, altR, latG, lngG, altG; 
var nyfac, nxfac, eyfac, exfac, lat0, lng0, alt0, camera3JSAlt; 
function SetBasePositions()
{
    basepositionOrigin = [ "Hilde", 47.6160995, 13.8121137, 748 ];  // this is subtracted from the data positions
    latG = basepositionOrigin[1]; 
    lngG = basepositionOrigin[2]; 
    altG = basepositionOrigin[3]; 
    latR = 0; lngR = 0; altR = 0; 
    for (var i = 0; i < svxents.length; i++) {
        if (svxents[i][0] == "p258b") {
            basepositionOrigin = svxents[i]; 
        }
    }
    lat0 = basepositionOrigin[1]; 
    lng0 = basepositionOrigin[2]; 
    alt0 = basepositionOrigin[3]; 
    
    var earthrad = 6378137; 
    nyfac = 2*Math.PI*earthrad/360; 
    nxfac = 0; 
    eyfac = 0; 
    exfac = nyfac*Math.cos(lat0*Math.PI/180); 
    
    SetCameraPositionG();
}


var peaks = [ 
    ["Schoneberg", 47.712315, 13.790972, 2000 ], 
    ["Dachstein", 47.47527777777778, 13.606388888888889, 2995 ], 
    ["Loser", 47.66083333333333, 13.771111111111113, 1837 ],
    ["Trisselwand", 47.64611111111111, 13.813333333333334, 1754 ],
    
    ["Trissenstein", 47.626666666666665, 13.789166666666667, 1201 ],
    ["Brauning Nase", 47.678381045318616, 13.805098487465617, 1769 ],
    //["Hildestein", 47.610426, 13.814096, 900 ],
    ["Rotelstein", 47.593488, 13.847536, 1614 ],
    ["Sarstein", 47.602606, 13.699005, 1975 ]
];

function reset31() 
{
    latR = latG - lat0; 
    lngR = lngG - lng0; 
    altR = altG - alt0; 
    SetCameraPositionG(); 
}


var camera, scene, renderer, controls, threejselement, vizcontainer;
var quantshowelement, quantshowtextelement, postextelement; 
var clock = new THREE.Clock();
var hoptime = null; 
var hopmode = 0; // 0 on ground, 1 going up, -1 going down, 2 on the up
var linewidth = 3; 
function ZhopGo() 
{
    hopmode = (hopmode == 0 ? 1 : -1); 
    hoptime = clock.elapsedTime; 
}
function Zhopdisplacement() 
{
    var hopheight = 1500.0; 
    if (hopmode === 0)
        return 0.0; 
    if (hopmode === 2)
        return hopheight; 
    if (hoptime === null)
        return 0.0; 
    var hsecs = clock.elapsedTime - hoptime; 
    if (hsecs > 2) {
        hoptime = null; 
        hopmode = (hopmode == 1 ? 2 : 0); 
        return (hopmode === 2 ? hopheight : 0); 
    }
    var x = Math.abs((hsecs-2)/2); 
    if (hopmode == -1)
        x = 1 - x; 
    var y = (x < 0.5 ? (1 - x*x*2) : (1 - x)*(1 - x)*2); 
    return hopheight*y; 
}

function latlngtopt(lat, lng, alt)
{
    var rlat = lat - lat0; 
    var rlng = lng - lng0; 
    return new THREE.Vector3(-(rlat*eyfac + rlng*exfac), alt, +(rlat*nyfac + rlng*nxfac)); 
}


var textlabelmaterials = [ ]; 
function MakeLabel(card, text, fillstyle, p, scale)
{
    var canvas1 = document.createElement('canvas');
    canvas1.width = 256;  canvas1.height = 32; 
    var context1 = canvas1.getContext('2d');
    context1.font = "28px Helvetica";
    context1.fillStyle = fillstyle;
    context1.fillText(text, 0, 20); 

// this one we can highlight it individually with a selection boolean
    var texture1 = new THREE.Texture(canvas1);  
    texture1.needsUpdate = true; 
    var textlabelmaterial = new THREE.ShaderMaterial({
        uniforms: { pixelsize: {type: 'f', value: 1.2}, 
                    aspect: { type: 'f', value: 1.0 },
                    textureaspect: { type: 'f', value: canvas1.width/canvas1.height }, 
                    texture: { value: texture1 },
                    closecolour: { type: 'v4', value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }, 
                    closedist: { type: 'f', value: 5.0 } 
                  }, 
        vertexShader: document.getElementById('vertex_shader_textlabel').textContent,
        fragmentShader: document.getElementById('fragment_shader_textlabel').textContent, 
        depthWrite:true, depthTest:true, 
        side: THREE.DoubleSide
    }); 
    textlabelmaterials.push(textlabelmaterial); 

    var textlabelpositionsbuff = new THREE.BufferAttribute(new Float32Array(4*3), 3);
    var textlabeluvsbuff = new THREE.BufferAttribute(new Float32Array(4*2), 2);
    for (var i = 0; i < 4; i++) {
        textlabelpositionsbuff.setXYZ(i, p.x, p.y, p.z); 
        textlabeluvsbuff.setXY(i, ((i == 0) || (i == 2) ? 0.0 : 1.0), (i <= 1 ? 0.0 : 1.0)); 
    }
    var indices = new Uint16Array(6);
    indices[0] = 0; indices[1] = 1; indices[2] = 2; 
    indices[3] = 1; indices[4] = 3; indices[5] = 2; 
    var buffergeometry = new THREE.BufferGeometry(); 
    buffergeometry.setIndex(new THREE.BufferAttribute(indices, 1));
    buffergeometry.addAttribute('position', textlabelpositionsbuff);
    buffergeometry.addAttribute('uv', textlabeluvsbuff);
    mesh1 = new THREE.Mesh(buffergeometry, textlabelmaterial); 
    card.add(mesh1);
}

var peaktrianglematerial; 
function LoadMountains(scene)
{
    var peakpositionbuff = new THREE.BufferAttribute(new Float32Array(peaks.length*9), 3); 
    var peakcorner = new Float32Array(peaks.length*3); 
    
    var card = new THREE.Object3D();
    for (var i = 0; i < peaks.length; i++) {
        var p = latlngtopt(peaks[i][1], peaks[i][2], peaks[i][3]); 
        peakpositionbuff.setXYZ(i*3, p.x, p.y, p.z);  peakpositionbuff.setXYZ(i*3+1, p.x, p.y, p.z);  peakpositionbuff.setXYZ(i*3+2, p.x, p.y, p.z); 
        peakcorner[i*3] = 0.0;  peakcorner[i*3+1] = 1.0;  peakcorner[i*3+2] = 2.0; 

        MakeLabel(card, peaks[i][0], "rgba(255,255,255,0.95)", p, 10); 
    }
    scene.add(card);
    
    buffergeometry = new THREE.BufferGeometry(); 
    buffergeometry.addAttribute('position', peakpositionbuff); 
    buffergeometry.addAttribute('pcorner', new THREE.BufferAttribute(peakcorner, 1)); 
    peaktrianglematerial = new THREE.ShaderMaterial({
        uniforms: { trianglesize: {type: 'f', value: 15.0}, 
                    aspect: { type: 'f', value: 1.0 }
                  }, 
        vertexShader: document.getElementById('vertexShader_peaktriangle').textContent,
        depthWrite:true, depthTest:true, 
        side: THREE.DoubleSide
    }); 
    
    var peaktriangles = new THREE.Mesh(buffergeometry, peaktrianglematerial);  
    scene.add(peaktriangles); 
}

var centrelinematerial; 
var centrelinebuffergeometry; 
function LoadCentrelines(scene)
{
    centrelinematerial = new THREE.ShaderMaterial({
        uniforms: { closecolour: { type: 'v4', value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }, 
                    closedist: { type: 'f', value: 5.0 }, 
                    selectedvsvxcaveindex: { type: 'f', value: -1.0 }
                  }, 
        vertexShader: document.getElementById('vertexShader_centreline').textContent,
        fragmentShader: document.getElementById('fragment_shader_centreline').textContent, 
        depthWrite:true, depthTest:true,  // not sure these work
        linewidth:3 
    });

    var centrelinepositionsbuff = new THREE.BufferAttribute(new Float32Array(svxlegs.length*2*3), 3);
    var cosslope = new Float32Array(svxlegs.length*2); 
    var svxcaveindex = new Float32Array(svxlegs.length*2); 
    for (var i = 0; i < svxlegs.length; i++) {
        var svxleg = svxlegs[i]; 
        var p0 = latlngtopt(svxleg[0], svxleg[1], svxleg[2]); 
        var p1 = latlngtopt(svxleg[3], svxleg[4], svxleg[5]); 
        centrelinepositionsbuff.setXYZ(i*2, p0.x, p0.y, p0.z); 
        centrelinepositionsbuff.setXYZ(i*2+1, p1.x, p1.y, p1.z); 
        var dx = p1.x - p0.x, dy = p1.y - p0.y, dz = p1.z - p0.z; 
        var lcosslope = Math.cos(Math.atan2(dy, Math.sqrt(dx*dx + dz*dz))); 
        cosslope[i*2] = lcosslope; 
        cosslope[i*2+1] = lcosslope; 
        svxcaveindex[i*2] = svxleg[6]; 
        svxcaveindex[i*2+1] = svxleg[6]; 
    }
    centrelinebuffergeometry = new THREE.BufferGeometry(); 
    centrelinebuffergeometry.addAttribute('position', centrelinepositionsbuff);
    centrelinebuffergeometry.addAttribute('cosslope', new THREE.BufferAttribute(cosslope, 1)); 
    centrelinebuffergeometry.addAttribute('svxcaveindex', new THREE.BufferAttribute(svxcaveindex, 1)); 

    var contour = new THREE.LineSegments(centrelinebuffergeometry, centrelinematerial);  
    scene.add(contour); 
}

var enttrianglematerial; 
var entgeometry; 
function LoadEntrances(scene)
{
    var entpositionbuff = new THREE.BufferAttribute(new Float32Array(svxents.length*9), 3); 
    var entcorner = new Float32Array(svxents.length*3); 
    var svxcaveindex = new Float32Array(svxents.length*3); 
    
    entgeometry = new THREE.BufferGeometry(); 
    entgeometry.addAttribute('position', entpositionbuff); 
    entgeometry.addAttribute('pcorner', new THREE.BufferAttribute(entcorner, 1)); 
    entgeometry.addAttribute('svxcaveindex', new THREE.BufferAttribute(svxcaveindex, 1)); 
    enttrianglematerial = new THREE.ShaderMaterial({
        uniforms: { trianglesize: {type: 'f', value: 10.0}, 
                    aspect: { type: 'f', value: 1.0 }, 
                    closecolour: { type: 'v4', value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }, 
                    closedist: { type: 'f', value: 5.0 }, 
                    selectedvsvxcaveindex: { type: 'f', value: -1.0 }
                  }, 
        vertexShader: document.getElementById('vertex_shader_enttriangle').textContent,
        fragmentShader: document.getElementById('fragment_shader_centreline').textContent, 
        depthWrite:true, depthTest:true, 
        side: THREE.DoubleSide
    }); 
    var enttriangles = new THREE.Mesh(entgeometry, enttrianglematerial);  
    scene.add(enttriangles); 

    var card = new THREE.Object3D();
    for (var i = 0; i < svxents.length; i++) {
        var p = latlngtopt(svxents[i][1], svxents[i][2], svxents[i][3]); 
        entpositionbuff.setXYZ(i*3, p.x, p.y, p.z);  entpositionbuff.setXYZ(i*3+1, p.x, p.y, p.z);  entpositionbuff.setXYZ(i*3+2, p.x, p.y, p.z); 
        entcorner[i*3] = 0.0;  entcorner[i*3+1] = 1.0;  entcorner[i*3+2] = 2.0; 
        svxcaveindex[i*3] = svxents[i][4];  svxcaveindex[i*3+1] = svxents[i][4];  svxcaveindex[i*3+2] = svxents[i][4]; 
        
        if (svxents[i][0].match(/p\d+[a-z]?$/) !== null) {
            MakeLabel(card, svxents[i][0], "rgba(0,200,200,0.95)", p, 0.5);  // rgba(0,200,200,0.95)
        }
    }
    scene.add(card);
}


function resize() 
{
    var width = vizcontainer.offsetWidth;
    var height = vizcontainer.offsetHeight;
    camera.aspect = width / height;
    peaktrianglematerial.uniforms.aspect.value = camera.aspect; 
    peaktrianglematerial.uniforms.trianglesize.value = 10/height; 
    enttrianglematerial.uniforms.aspect.value = camera.aspect; 
    enttrianglematerial.uniforms.trianglesize.value = 5/width; 
    for (var i = 0; i < textlabelmaterials.length; i++) {
        textlabelmaterials[i].uniforms.aspect.value = camera.aspect; 
        textlabelmaterials[i].uniforms.pixelsize.value = 60/width; 
    }
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}


function update(dt) 
{
    resize();
    camera.updateProjectionMatrix();
    controls.update(dt);
}

function render(dt) 
{
    renderer.render(scene, camera);
}

function animate(t) 
{
    if (hopmode !== 0)
        camera.position.y = camera3JSAlt + Zhopdisplacement(); 
    //$("#camerapos").text("cam:"+camera.position.x.toFixed(1)+" "+camera.position.y.toFixed(1)+" "+camera.position.z.toFixed(1))
    requestAnimationFrame(animate);
    if  ((touchmovestate == 1) && (clock.elapsedTime - touchtime > 1)) {
        touchmovestate = 5; 
        selecteffort(touchStart.x, touchStart.y, "fromanimate")
    }
    update(clock.getDelta());
    render(clock.getDelta());
}

function tryabsoluteorient(event)
{
    window.removeEventListener('absolutedeviceorientation', tryabsoluteorient);  
    quantshowshow("**"); 
    console.log("absoluteorient", event); 
    quantshowtextelement.textContent = "gting "+event.alpha.toFixed(1)+" "+event.absolute; 
    if ((event.alpha !== null) && event.absolute) {
        controls.alphaoffset = event.alpha - GdeviceOrientation.alpha; // GdeviceOrientation is global var accessing deviceOrientation within the controls library
        quantshowtextelement.textContent = "AA-offs: "+controls.alphaoffset.toFixed(1); 
    }
    quantshowhidedelay(1500); 
}

var quantshowhidetimeout = null; 
function quantshowhide()  
{
    quantshowelement.style.display = "none";  
    if (quantshowhidetimeout !== null) {
        clearTimeout(quantshowhidetimeout);  
        quantshowhidetimeout = null; 
    }
}
function quantshowhidedelay(dt)  { if (quantshowhidetimeout === null)  quantshowhidetimeout = setTimeout(quantshowhide, dt);  }
function quantshowshow(qtext)  
{ 
    if (quantshowhidetimeout !== null) {
        clearTimeout(quantshowhidetimeout);  
        quantshowhidetimeout = null; 
    }
    quantshowelement.style.display = "block"; 
    if (qtext) {
        quantshowtextelement.textContent = qtext; 
        quantshowtextelement.style.display = "block"; 
        postextelement.style.display = "none"; 
    } else {
        quantshowtextelement.style.display = "none"; 
        postextelement.style.display = "block"; 
    }
}

function setclosedistvalue(closedistvalue)
{
    centrelinematerial.uniforms.closedist.value = closedistvalue; 
    enttrianglematerial.uniforms.closedist.value = closedistvalue; 
    for (var i = 0; i < textlabelmaterials.length; i++) 
        textlabelmaterials[i].uniforms.closedist.value = closedistvalue; 
}

function setselectedindex(selectedvsvxcaveindex)
{
    centrelinematerial.uniforms.selectedvsvxcaveindex.value = selectedvsvxcaveindex; 
    enttrianglematerial.uniforms.selectedvsvxcaveindex.value = selectedvsvxcaveindex; 
    //for (var i = 0; i < textlabelmaterials.length; i++) 
    //    textlabelmaterials[i].uniforms.closedist.value = closedistvalue; 
}

var touchStart = new THREE.Vector2(), touchEnd = new THREE.Vector2(), touchDelta = new THREE.Vector2();
var alphaoffsetStart, touchtime; 
var touchmovestate = 0; // 1 is touchdrag, 2 is dragging left-right for alpha compass rotate, 3 for depth of fogbrightness, 4 pinch for FOV change, 5 for point selection
function touchstartfunc(event) 
{
    event.stopPropagation(); 
    touchtime = clock.elapsedTime; 
    if (event.touches.length == 1) {
        touchStart.set(event.touches[0].pageX, event.touches[0].pageY); 
        touchmovestate = 1; // pre-single move, but don't know direction of drag
    } else if ((event.touches.length == 2) && (touchmovestate <= 1)) {
        touchStart.set(event.touches[1].pageX - event.touches[0].pageX, event.touches[1].pageX - event.touches[0].pageY); 
        touchmovevalueStart = camera.fov; 
        quantshowshow("**"); 
        touchmovestate = 4; 
    }
}


// selection procedure that will batchwise look for an intersection clicked
// should be in its own object
var isvxents = 0, minisvxents = -1, minsvxentdsq = -1, vStart = new THREE.Vector3(), vEnd = new THREE.Vector3(); 
var selectbatchproctimeout = null; 
var selectposx, selectposy; 
var pickray = new THREE.Raycaster()
function selectbatchproc()
{
    if (selectbatchproctimeout == null) {
        isvxents = 0; 
        minisvxents = -1; 
        minsvxentdsq = -1; 
        selectbatchproctimeout = setTimeout(selectbatchproc, 10); 
        return; 
    } else {
        selectbatchproctimeout = null; 
    }
    
    for (var j = 501; j > 0; j--) { // batch in this callback to work through
        if ((isvxents == svxents.length) && (minsvxentdsq != -1)) {
            var pix2dist = Math.sqrt(minsvxentdsq)*window.innerHeight; 
            if (pix2dist <= 60)
                break; 
        }
        if (isvxents < svxents.length) {
            vStart.fromArray(entgeometry.attributes.position.array, isvxents*9);
            //var dsq = pickray.ray.distanceSqToPoint(vStart); 
            vStart.project(camera); 
            if (vStart.z > 0.0) {
                var dx = (vStart.x - selectposx)*camera.aspect, dy = vStart.y - selectposy; 
                var dsq = dx*dx + dy*dy; 
                if ((minisvxents == -1) || (dsq < minsvxentdsq)) {
                    minsvxentdsq = dsq; 
                    minisvxents = isvxents; 
                    vEnd.fromArray(entgeometry.attributes.position.array, isvxents*9);
                }
            }
        } else if (isvxents < svxents.length + svxlegs.length) {
            var i = isvxents - svxents.length; 
            vStart.fromArray(centrelinebuffergeometry.attributes.position.array, i*6);
            vEnd.fromArray(centrelinebuffergeometry.attributes.position.array, i*6+3);
            vStart.project(camera); 
            vEnd.project(camera); 
            if ((vStart.z > 0.0) && (vEnd.z > 0.0)) {
                var dx = (selectposx - vStart.x)*camera.aspect, dy = selectposy - vStart.y; 
                var vx = (vEnd.x - vStart.x)*camera.aspect, vy = vEnd.y - vStart.y; 
                var vsq = vx*vx + vy*vy; 
                var ddv = dx*vx + dy*vy; 
                var lam = (((ddv <= 0) || (vsq == 0)) ? 0 : (ddv > vsq ? 1.0 : ddv/vsq)); 
                var ex = dx - vx*lam, ey = dy - vy*lam; 
                var esq = ex*ex + ey*ey; 
                if ((minisvxents == -1) || (esq < minsvxentdsq)) {
                    minsvxentdsq = esq; 
                    minisvxents = isvxents; 
                }
            }
        } else {
            break; 
        }
        isvxents++; 
    }
    if (j == 0) {
        selectbatchproctimeout = setTimeout(selectbatchproc, 10); 
        console.log("batch", isvxents); 
    } else {
        if (minisvxents < svxents.length) {
            console.log(minsvxentdsq, minisvxents, vEnd, svxents[minisvxents]); 
            quantshowtextelement.textContent = "Entrance of: "+svxents[minisvxents][0]; 
            setselectedindex(svxents[minisvxents][4]); 
        } else if (minisvxents < svxents.length + svxlegs.length) {
            var ni = svxlegs[minisvxents - svxents.length][6]; 
            if (ni >= 0) {
                quantshowtextelement.textContent = "Cave: "+svxnames[ni]; 
                quantshowhidedelay(5000); 
                setselectedindex(ni); 
            }
        }
    }
}

function selecteffort(px, py, sesource)
{
    quantshowshow("SELECT"+px+" "+py+" "+sesource); 
    selectposx = (px/window.innerWidth)*2 - 1; 
    selectposy = -(py/window.innerHeight)*2 + 1; 
    console.log("bbbb "+selectposx+" "+selectposy); 
    pickray.setFromCamera({x:selectposx, y:selectposy}, camera); 
    var rfac = 150.0; 
    if (pickposmesh) {
        pickposmesh.position.set(pickray.ray.origin.x + pickray.ray.direction.x*rfac, pickray.ray.origin.y + pickray.ray.direction.y*rfac, pickray.ray.origin.z + pickray.ray.direction.z*rfac); 
        console.log(pickposmesh.position, "f", footposmesh.position); 
    }
    selectbatchproc(); 
}; 

function touchholdfunc(event) 
{ 
    event.preventDefault(); 
    event.stopPropagation(); 
    if (touchmovestate == 1) {
        touchmovestate = 5; 
        selecteffort(event.pageX, event.pageY, "contextevent"); 
    }
    return false 
}; 

function touchmovefunc(event)
{
    event.preventDefault(); 
    event.stopPropagation(); 
    var touchmovepixelsrequired = 20; 
    if (event.touches.length == 1) {
        touchEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        touchDelta.subVectors(touchEnd, touchStart); 
        if ((touchmovestate == 1) && (Math.max(Math.abs(touchDelta.x), Math.abs(touchDelta.y)*2) > touchmovepixelsrequired)) {
            touchmovestate = (Math.abs(touchDelta.x) >= Math.abs(touchDelta.y) ? 2 : 3); 
            touchmovevalueStart = (touchmovestate == 2 ? controls.alphaoffset : centrelinematerial.uniforms.closedist.value); 
            quantshowshow("**");   // drops through
            //if (touchmovestate == 2)
            //    controls.alphalock = true; 
        }
        if  ((touchmovestate == 1) && (clock.elapsedTime - touchtime > 1)) {
            touchmovestate = 5; 
            selecteffort(touchStart.x, touchStart.y, "touchholdmove")
        }

        if (touchmovestate == 2) {
            //controls.alpha += THREE.Math.degToRad(touchDelta.x*0.1);  // didnt work
            //touchStart.set(touchEnd.x, touchEnd.y); // make incremental so the holding flag within the controls can also work
            controls.alphaoffset = touchmovevalueStart + touchDelta.x*0.3;  
            quantshowtextelement.textContent = "A-offs: "+controls.alphaoffset.toFixed(0); 
        } else if (touchmovestate == 3) {
            setclosedistvalue(Math.max(0.0, touchmovevalueStart - Math.max(1.0, touchmovevalueStart)*touchDelta.y*0.02)); 
            quantshowtextelement.textContent = "Light: "+(centrelinematerial.uniforms.closedist.value).toFixed(0)+"m"; 
        }
    } else if (event.touches.length == 2) {
        if (touchmovestate == 4) {
            touchEnd.set(event.touches[1].pageX - event.touches[0].pageX, event.touches[1].pageX - event.touches[0].pageY); 
            camera.fov = Math.min(175.0, Math.max(1.0, touchmovevalueStart*(touchStart.length()/touchEnd.length()))); 
            quantshowtextelement.textContent = "FOV: "+camera.fov.toFixed(0)+"deg"; 
        }
    }
    return false; 
}

function touchendfunc(event)
{
    event.preventDefault(); 
    //if (touchmovestate == 2)
    //    controls.alphalock = false; 
    if (touchmovestate > 0)
        quantshowhidedelay(1500); 
    touchmovestate = 0; 
}


var geomeshtorus, flatmaterial; 
function init() 
{
    renderer = new THREE.WebGLRenderer();
    threejselement = renderer.domElement;
    vizcontainer = document.getElementById('viz');
    vizcontainer.appendChild(threejselement);
    quantshowelement = document.getElementById('quantshow'); 
    quantshowtextelement = document.getElementById('quantshowtext'); 
    postextelement = document.getElementById('postext'); 
    
    scene = new THREE.Scene();
    var fieldofview = 30; // degrees (smaller is more tunnel like)
    var aspect = 1;       // reset in resize()
    var neardistance = 5; 
    var fardistance = 70000; 
    camera = new THREE.PerspectiveCamera(fieldofview, aspect, neardistance, fardistance);
    camera3JSAlt = alt0; 
    camera.position.set(0, camera3JSAlt, 0); 
    scene.add(camera); 

    SetBasePositions(); 

    /*var gsurf = new THREE.TorusGeometry(10hopmode, 4, 90, 30); 
    flatmaterial = new THREE.MeshPhongMaterial({ color: "rgb(220,50,210)", opacity: 0.1, specular: 0x222222, shininess: 40, side: THREE.DoubleSide, vertexColors: THREE.FaceColors, shading: THREE.FlatShading });  
    gsurf.computeBoundingSphere();
    geomeshtorus = new THREE.Mesh(gsurf, flatmaterial); 
    geomeshtorus.rotateX(Math.PI/2); 
    geomeshtorus.translateZ(-(alt0-50)); 
    scene.add(geomeshtorus);  */

    controls = new THREE.DeviceOrientationControls(camera, true);
    controls.connect();
    controls.update();
    window.addEventListener('keydown', function(event) {
        if (event.keyCode == 37) 
            GdeviceOrientation.gamma += 5; 
        else if (event.keyCode == 39) 
            GdeviceOrientation.gamma -= 5; 
        else if (event.keyCode == 38)
            GdeviceOrientation.beta += 5; 
        else if (event.keyCode == 40)
            GdeviceOrientation.beta -= 5; 
    });

    
    var light = new THREE.PointLight(0xffffff);
    light.position.set(0, 2500, 0);
    scene.add(light);

    LoadMountains(scene); 
    LoadCentrelines(scene); 
    LoadEntrances(scene); 
    LoadTrail(scene); 
    LoadFootpos(scene); 
    //LoadPickPos(scene); 
    
    var corners = [ [0,-1,0xFFFFFF]/*North*/, [1,0,0x55FFAA]/*east*/, [0,1,0xFF3333], [-1,0,0xFFFF33] ];
    var g = new THREE.Geometry(); 
    var dd = 500; 
    for (var j = 0; j < corners.length; j++) {
        var g1 = new THREE.Geometry();
        
        g1.vertices.push(new THREE.Vector3(dd*corners[j][0], alt0, dd*corners[j][1])); 
        g1.vertices.push(new THREE.Vector3(dd*corners[j][0], alt0+dd, dd*corners[j][1])); 
        var m0 = new THREE.LineBasicMaterial({ color:corners[j][2], opacity:0.7, linewidth:linewidth, depthWrite:true }); 
        var contour = new THREE.Line(g1, m0, THREE.LineStrip); // for disjoint line segments use THREE.LinePieces
        scene.add(contour); 
        g.vertices.push(new THREE.Vector3(dd*corners[j][0], alt0, dd*corners[j][1])); 
    }
    g.vertices.push(new THREE.Vector3(dd*corners[0][0], alt0, dd*corners[0][1])); 
    var m = new THREE.LineBasicMaterial({ color:0xFF0000, opacity:1.0, linewidth:linewidth, depthWrite:true }); 
    var contour = new THREE.Line(g, m, THREE.LineStrip); 
    scene.add(contour); 
    scene.fog = new THREE.Fog(0x202020, 10, 20000);  // near and far
        
    document.getElementById("camerahop").addEventListener("click", ZhopGo); 
    document.getElementById("reset31").addEventListener("click", reset31); 
    document.getElementById("test1").addEventListener("click", function(event) {  event.stopPropagation(); console.log("hihi"); return true; }, true); 
    document.getElementById("magorientset").addEventListener("click", function(event) { event.preventDefault(); window.addEventListener('absolutedeviceorientation', tryabsoluteorient); }); 

    quantshowelement.addEventListener("click", quantshowhide); 
    document.getElementById("qshow").addEventListener("click", function(event) { quantshowshow(false); }); 

    vizcontainer.addEventListener('touchstart', touchstartfunc, false);
    vizcontainer.addEventListener('touchend', touchendfunc, false);
    vizcontainer.addEventListener('touchcancel', touchendfunc, false);
    vizcontainer.addEventListener('touchmove', touchmovefunc, false);
    vizcontainer.addEventListener('contextmenu', touchholdfunc, false); 

    window.addEventListener('resize', resize);
    setTimeout(resize, 1);
}

init();
animate();

// add GPS reader to this or do fake positions
//var watchID = navigator.geolocation.watchPosition(geo_success, geo_error, {enableHighAccuracy:true, timeout:27000, maximumAge:30000}); 
fakegpsgenerator(); // for desktop use


console.log("dididi"); 


  </script>
  </body>
</html>

